<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Block Blast - El Dorado</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Archivo+Narrow:wght@700&family=Geist:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-user-select: none;
      user-select: none;
    }

    :root {
      --bg: #121211;
      --surface: #1a1a19;
      --surface-secondary: #2a2a28;
      --text-primary: #fcfcfc;
      --text-secondary: #b9b9b3;
      --brand: #e5e517;
      --brand-light: #eaea43;
      --brand-glow: rgba(229, 229, 23, 0.15);
      --stroke-secondary: #2a2a28;
      --danger: #e54017;
      --border-small: 4px;
      --border-medium: 8px;
      --spacing-1: 8px;
      --spacing-1-5: 12px;
      --spacing-2: 16px;
      --spacing-3: 24px;
      --spacing-4: 32px;
    }

    body {
      background: var(--bg);
      color: var(--text-primary);
      font-family: 'Geist', -apple-system, sans-serif;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      touch-action: none;
    }

    /* Status Bar */
    .status-bar {
      width: 100%;
      max-width: 393px;
      height: 47px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 var(--spacing-2);
      font-size: 14px;
      font-weight: 600;
    }

    /* Top Bar */
    .top-bar {
      width: 100%;
      max-width: 393px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 var(--spacing-2);
      border-bottom: 1px solid var(--stroke-secondary);
    }

    .top-bar-logo {
      display: flex;
      align-items: center;
      gap: var(--spacing-1);
    }

    .logo-icon {
      width: 28px;
      height: 28px;
      background: var(--brand);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Archivo Narrow', sans-serif;
      font-weight: 700;
      font-size: 16px;
      color: var(--bg);
    }

    .top-bar-title {
      font-family: 'Archivo Narrow', sans-serif;
      font-weight: 700;
      font-size: 18px;
      letter-spacing: 1px;
    }

    /* Score Area */
    .score-area {
      width: 100%;
      max-width: 393px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--spacing-1-5) var(--spacing-2);
    }

    .score-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }

    .score-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1.5px;
      font-family: 'Archivo Narrow', sans-serif;
    }

    .score-value {
      font-size: 28px;
      font-weight: 700;
      color: var(--brand);
      font-family: 'Geist', sans-serif;
      line-height: 1;
    }

    .score-value.best {
      color: var(--text-primary);
      font-size: 20px;
    }

    .combo-indicator {
      background: var(--brand-glow);
      border: 1px solid var(--brand);
      border-radius: 20px;
      padding: 4px 14px;
      font-size: 13px;
      font-weight: 700;
      color: var(--brand);
      font-family: 'Archivo Narrow', sans-serif;
      letter-spacing: 1px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .combo-indicator.visible {
      opacity: 1;
    }

    /* Game Grid */
    .grid-container {
      width: 100%;
      max-width: 393px;
      padding: 0 var(--spacing-1);
      display: flex;
      justify-content: center;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      gap: 3px;
      width: 340px;
      height: 340px;
      background: var(--surface);
      border-radius: var(--border-medium);
      padding: 6px;
      border: 1px solid var(--stroke-secondary);
    }

    .cell {
      background: var(--surface-secondary);
      border-radius: 3px;
      transition: background 0.15s, transform 0.15s;
      position: relative;
    }

    .cell.filled {
      background: var(--brand);
      box-shadow: inset 0 -2px 0 rgba(0,0,0,0.2), 0 0 6px var(--brand-glow);
    }

    .cell.preview {
      background: rgba(229, 229, 23, 0.35);
      border: 1px solid rgba(229, 229, 23, 0.5);
    }

    .cell.invalid-preview {
      background: rgba(229, 64, 23, 0.25);
      border: 1px solid rgba(229, 64, 23, 0.4);
    }

    .cell.clearing {
      animation: clearPulse 0.4s ease-out;
    }

    @keyframes clearPulse {
      0% { background: var(--brand); transform: scale(1.1); }
      50% { background: #fff; transform: scale(1.15); }
      100% { background: var(--surface-secondary); transform: scale(1); }
    }

    /* Pieces Area */
    .pieces-area {
      width: 100%;
      max-width: 393px;
      padding: var(--spacing-2) var(--spacing-1);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: var(--spacing-2);
      min-height: 140px;
    }

    .piece-slot {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 110px;
      height: 110px;
      background: var(--surface);
      border-radius: var(--border-medium);
      border: 1px solid var(--stroke-secondary);
      cursor: grab;
      transition: transform 0.2s, box-shadow 0.2s, opacity 0.3s;
    }

    .piece-slot:active {
      cursor: grabbing;
    }

    .piece-slot.dragging {
      opacity: 0.4;
      transform: scale(0.9);
    }

    .piece-slot.used {
      opacity: 0.15;
      pointer-events: none;
    }

    .piece-grid {
      display: grid;
      gap: 2px;
    }

    .piece-cell {
      width: 18px;
      height: 18px;
      border-radius: 2px;
    }

    .piece-cell.active {
      background: var(--brand);
      box-shadow: inset 0 -1px 0 rgba(0,0,0,0.2);
    }

    .piece-cell.empty {
      background: transparent;
    }

    /* Floating Piece (during drag) */
    .floating-piece {
      position: fixed;
      pointer-events: none;
      z-index: 100;
      display: grid;
      gap: 3px;
      opacity: 0.9;
    }

    .floating-cell {
      width: 38px;
      height: 38px;
      border-radius: 3px;
      background: var(--brand);
      box-shadow: inset 0 -2px 0 rgba(0,0,0,0.2), 0 0 12px var(--brand-glow);
    }

    .floating-cell.empty {
      background: transparent;
      box-shadow: none;
    }

    /* Bottom Section */
    .bottom-bar {
      width: 100%;
      max-width: 393px;
      padding: var(--spacing-1) var(--spacing-2) var(--spacing-3);
      display: flex;
      justify-content: center;
      gap: var(--spacing-2);
      margin-top: auto;
    }

    .btn {
      font-family: 'Archivo Narrow', sans-serif;
      font-weight: 700;
      font-size: 14px;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      border: none;
      border-radius: var(--border-medium);
      padding: 12px 24px;
      cursor: pointer;
      transition: transform 0.1s, opacity 0.2s;
    }

    .btn:active {
      transform: scale(0.96);
    }

    .btn-primary {
      background: var(--brand);
      color: var(--bg);
    }

    .btn-secondary {
      background: var(--surface-secondary);
      color: var(--text-primary);
      border: 1px solid var(--stroke-secondary);
    }

    /* Game Over Overlay */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(18, 18, 17, 0.92);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s;
    }

    .overlay.visible {
      opacity: 1;
      pointer-events: all;
    }

    .overlay-card {
      background: var(--surface);
      border: 1px solid var(--stroke-secondary);
      border-radius: 16px;
      padding: var(--spacing-4);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--spacing-3);
      width: 300px;
    }

    .overlay-title {
      font-family: 'Archivo Narrow', sans-serif;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .overlay-score {
      font-size: 56px;
      font-weight: 700;
      color: var(--brand);
      line-height: 1;
    }

    .overlay-best {
      font-size: 14px;
      color: var(--text-secondary);
    }

    .overlay-best span {
      color: var(--text-primary);
      font-weight: 600;
    }

    .overlay-buttons {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-1);
      width: 100%;
    }

    .overlay-buttons .btn {
      width: 100%;
      padding: 14px;
      font-size: 16px;
    }

    /* Leaderboard */
    .leaderboard-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
    }

    /* Score popup animation */
    .score-popup {
      position: fixed;
      pointer-events: none;
      z-index: 150;
      font-family: 'Archivo Narrow', sans-serif;
      font-weight: 700;
      font-size: 24px;
      color: var(--brand);
      text-shadow: 0 0 10px var(--brand-glow);
      animation: scoreFloat 0.8s ease-out forwards;
    }

    @keyframes scoreFloat {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-60px) scale(1.3); }
    }

    /* Home Indicator */
    .home-indicator {
      width: 134px;
      height: 5px;
      background: var(--text-primary);
      border-radius: 3px;
      opacity: 0.2;
      margin-bottom: 8px;
    }
  </style>
</head>
<body>
  <!-- Top Bar -->
  <div class="top-bar">
    <div class="top-bar-logo">
      <div class="logo-icon">E</div>
      <span class="top-bar-title">BLOCK BLAST</span>
    </div>
    <button class="btn btn-secondary leaderboard-btn" id="leaderboardBtn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M12 20V10M18 20V4M6 20v-4"/>
      </svg>
      RANKING
    </button>
  </div>

  <!-- Score Area -->
  <div class="score-area">
    <div class="score-box">
      <span class="score-label">Puntos</span>
      <span class="score-value" id="score">0</span>
    </div>
    <div class="combo-indicator" id="combo">COMBO x2</div>
    <div class="score-box">
      <span class="score-label">Mejor</span>
      <span class="score-value best" id="bestScore">0</span>
    </div>
  </div>

  <!-- Game Grid -->
  <div class="grid-container">
    <div class="grid" id="grid"></div>
  </div>

  <!-- Pieces -->
  <div class="pieces-area" id="piecesArea"></div>

  <!-- Bottom -->
  <div class="bottom-bar">
    <button class="btn btn-secondary" id="newGameBtn">NUEVO JUEGO</button>
  </div>

  <div class="home-indicator"></div>

  <!-- Game Over Overlay -->
  <div class="overlay" id="gameOverOverlay">
    <div class="overlay-card">
      <div class="overlay-title">Juego Terminado</div>
      <div class="overlay-score" id="finalScore">0</div>
      <div class="overlay-best">Mejor puntaje: <span id="finalBest">0</span></div>
      <div class="overlay-buttons">
        <button class="btn btn-primary" id="playAgainBtn">JUGAR DE NUEVO</button>
        <button class="btn btn-secondary" id="shareBtn">COMPARTIR PUNTAJE</button>
      </div>
    </div>
  </div>

  <script>
    // ========== GAME STATE ==========
    const GRID_SIZE = 8;
    let grid = [];
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('blockblast_best') || '0');
    let currentPieces = [];
    let draggingPiece = null;
    let floatingEl = null;
    let comboCount = 0;

    // ========== PIECE DEFINITIONS ==========
    const PIECES = [
      // Single
      { shape: [[1]], color: 'brand' },
      // 2-blocks
      { shape: [[1, 1]], color: 'brand' },
      { shape: [[1], [1]], color: 'brand' },
      // 3-blocks line
      { shape: [[1, 1, 1]], color: 'brand' },
      { shape: [[1], [1], [1]], color: 'brand' },
      // L-shapes
      { shape: [[1, 0], [1, 1]], color: 'brand' },
      { shape: [[0, 1], [1, 1]], color: 'brand' },
      { shape: [[1, 1], [1, 0]], color: 'brand' },
      { shape: [[1, 1], [0, 1]], color: 'brand' },
      // T-shapes
      { shape: [[1, 1, 1], [0, 1, 0]], color: 'brand' },
      { shape: [[0, 1, 0], [1, 1, 1]], color: 'brand' },
      // 4-blocks line
      { shape: [[1, 1, 1, 1]], color: 'brand' },
      { shape: [[1], [1], [1], [1]], color: 'brand' },
      // 2x2 square
      { shape: [[1, 1], [1, 1]], color: 'brand' },
      // 5-blocks line
      { shape: [[1, 1, 1, 1, 1]], color: 'brand' },
      { shape: [[1], [1], [1], [1], [1]], color: 'brand' },
      // S/Z shapes
      { shape: [[1, 1, 0], [0, 1, 1]], color: 'brand' },
      { shape: [[0, 1, 1], [1, 1, 0]], color: 'brand' },
      // 3x3 L
      { shape: [[1, 0, 0], [1, 0, 0], [1, 1, 1]], color: 'brand' },
      { shape: [[0, 0, 1], [0, 0, 1], [1, 1, 1]], color: 'brand' },
      { shape: [[1, 1, 1], [1, 0, 0], [1, 0, 0]], color: 'brand' },
      { shape: [[1, 1, 1], [0, 0, 1], [0, 0, 1]], color: 'brand' },
      // 3x3 square
      { shape: [[1, 1, 1], [1, 1, 1], [1, 1, 1]], color: 'brand' },
    ];

    // ========== INIT ==========
    function init() {
      grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
      score = 0;
      comboCount = 0;
      updateScore();
      renderGrid();
      spawnPieces();
      document.getElementById('gameOverOverlay').classList.remove('visible');
    }

    // ========== GRID RENDERING ==========
    function renderGrid() {
      const gridEl = document.getElementById('grid');
      gridEl.innerHTML = '';
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell' + (grid[r][c] ? ' filled' : '');
          cell.dataset.row = r;
          cell.dataset.col = c;
          gridEl.appendChild(cell);
        }
      }
    }

    // ========== PIECES ==========
    function getRandomPiece() {
      return { ...PIECES[Math.floor(Math.random() * PIECES.length)], used: false };
    }

    function spawnPieces() {
      currentPieces = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
      renderPieces();

      if (!canPlaceAnyPiece()) {
        setTimeout(gameOver, 300);
      }
    }

    function renderPieces() {
      const area = document.getElementById('piecesArea');
      area.innerHTML = '';

      currentPieces.forEach((piece, index) => {
        const slot = document.createElement('div');
        slot.className = 'piece-slot' + (piece.used ? ' used' : '');
        slot.dataset.index = index;

        if (!piece.used) {
          const rows = piece.shape.length;
          const cols = piece.shape[0].length;
          const pieceGrid = document.createElement('div');
          pieceGrid.className = 'piece-grid';
          pieceGrid.style.gridTemplateColumns = `repeat(${cols}, 18px)`;
          pieceGrid.style.gridTemplateRows = `repeat(${rows}, 18px)`;

          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const cell = document.createElement('div');
              cell.className = 'piece-cell ' + (piece.shape[r][c] ? 'active' : 'empty');
              pieceGrid.appendChild(cell);
            }
          }
          slot.appendChild(pieceGrid);

          // Touch events
          slot.addEventListener('touchstart', (e) => startDrag(e, index), { passive: false });
          slot.addEventListener('mousedown', (e) => startDragMouse(e, index));
        }

        area.appendChild(slot);
      });
    }

    // ========== DRAG & DROP ==========
    function startDrag(e, pieceIndex) {
      e.preventDefault();
      const piece = currentPieces[pieceIndex];
      if (piece.used) return;

      draggingPiece = { index: pieceIndex, piece };
      dragOffsetY = 80; // offset for touch so finger doesn't block view
      const touch = e.touches[0];

      // Mark slot as dragging
      document.querySelectorAll('.piece-slot')[pieceIndex].classList.add('dragging');

      createFloatingPiece(piece, touch.clientX, touch.clientY);

      const moveHandler = (e2) => {
        e2.preventDefault();
        const t = e2.touches[0];
        moveFloatingPiece(t.clientX, t.clientY, piece);
        showPreview(t.clientX, t.clientY, piece);
      };

      const endHandler = (e2) => {
        const t = e2.changedTouches[0];
        endDrag(t.clientX, t.clientY, piece, pieceIndex);
        document.removeEventListener('touchmove', moveHandler);
        document.removeEventListener('touchend', endHandler);
      };

      document.addEventListener('touchmove', moveHandler, { passive: false });
      document.addEventListener('touchend', endHandler);
    }

    function startDragMouse(e, pieceIndex) {
      e.preventDefault();
      const piece = currentPieces[pieceIndex];
      if (piece.used) return;

      draggingPiece = { index: pieceIndex, piece };
      dragOffsetY = 0; // no offset for mouse - piece goes right at cursor
      document.querySelectorAll('.piece-slot')[pieceIndex].classList.add('dragging');

      createFloatingPiece(piece, e.clientX, e.clientY);

      const moveHandler = (e2) => {
        moveFloatingPiece(e2.clientX, e2.clientY, piece);
        showPreview(e2.clientX, e2.clientY, piece);
      };

      const endHandler = (e2) => {
        endDrag(e2.clientX, e2.clientY, piece, pieceIndex);
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('mouseup', endHandler);
      };

      document.addEventListener('mousemove', moveHandler);
      document.addEventListener('mouseup', endHandler);
    }

    function createFloatingPiece(piece, x, y) {
      removeFloatingPiece();
      const rows = piece.shape.length;
      const cols = piece.shape[0].length;

      floatingEl = document.createElement('div');
      floatingEl.className = 'floating-piece';
      floatingEl.style.gridTemplateColumns = `repeat(${cols}, 38px)`;
      floatingEl.style.gridTemplateRows = `repeat(${rows}, 38px)`;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = document.createElement('div');
          cell.className = piece.shape[r][c] ? 'floating-cell' : 'floating-cell empty';
          floatingEl.appendChild(cell);
        }
      }

      document.body.appendChild(floatingEl);
      moveFloatingPiece(x, y, piece);
    }

    // Drag offset: 0 for mouse, offset for touch so finger doesn't cover piece
    let dragOffsetY = 0;

    function moveFloatingPiece(x, y, piece) {
      if (floatingEl) {
        const rows = piece.shape.length;
        const cols = piece.shape[0].length;
        const cellSize = 41; // 38px cell + 3px gap
        const pieceW = cols * cellSize;
        const pieceH = rows * cellSize;
        floatingEl.style.left = (x - pieceW / 2) + 'px';
        floatingEl.style.top = (y - dragOffsetY - pieceH / 2) + 'px';
      }
    }

    function removeFloatingPiece() {
      if (floatingEl) {
        floatingEl.remove();
        floatingEl = null;
      }
    }

    function getGridPosition(clientX, clientY) {
      const gridEl = document.getElementById('grid');
      const rect = gridEl.getBoundingClientRect();
      const padding = 6;
      const cellSize = (rect.width - padding * 2) / GRID_SIZE;
      const col = Math.floor((clientX - rect.left - padding) / cellSize);
      const row = Math.floor((clientY - rect.top - padding) / cellSize);
      return { row, col };
    }

    function getPlacement(clientX, clientY, piece) {
      // The placement target is offset up from cursor (same as floating visual)
      const targetY = clientY - dragOffsetY;
      const { row, col } = getGridPosition(clientX, targetY);
      const rows = piece.shape.length;
      const cols = piece.shape[0].length;
      // Anchor at center of piece
      const startRow = row - Math.floor((rows - 1) / 2);
      const startCol = col - Math.floor((cols - 1) / 2);
      return { startRow, startCol };
    }

    function showPreview(clientX, clientY, piece) {
      clearPreview();
      const { startRow, startCol } = getPlacement(clientX, clientY, piece);
      const canPlace = canPlacePiece(piece.shape, startRow, startCol);

      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[0].length; c++) {
          if (!piece.shape[r][c]) continue;
          const gr = startRow + r;
          const gc = startCol + c;
          if (gr < 0 || gr >= GRID_SIZE || gc < 0 || gc >= GRID_SIZE) continue;

          const cellEl = document.querySelector(`.cell[data-row="${gr}"][data-col="${gc}"]`);
          if (cellEl && !grid[gr][gc]) {
            cellEl.classList.add(canPlace ? 'preview' : 'invalid-preview');
          }
        }
      }
    }

    function clearPreview() {
      document.querySelectorAll('.cell.preview, .cell.invalid-preview').forEach(el => {
        el.classList.remove('preview', 'invalid-preview');
      });
    }

    function endDrag(clientX, clientY, piece, pieceIndex) {
      clearPreview();
      removeFloatingPiece();

      document.querySelectorAll('.piece-slot').forEach(s => s.classList.remove('dragging'));

      const { startRow, startCol } = getPlacement(clientX, clientY, piece);

      if (canPlacePiece(piece.shape, startRow, startCol)) {
        placePiece(piece.shape, startRow, startCol);
        currentPieces[pieceIndex].used = true;

        // Count cells placed
        let cellCount = 0;
        piece.shape.forEach(row => row.forEach(c => { if (c) cellCount++; }));
        addScore(cellCount);

        // Check for line clears
        const cleared = checkAndClearLines();
        if (cleared > 0) {
          comboCount++;
          const comboMultiplier = Math.min(comboCount, 5);
          const linePoints = cleared * GRID_SIZE * 10 * comboMultiplier;
          addScore(linePoints);
          showCombo(comboMultiplier);
          showScorePopup(linePoints, clientX, clientY - 100);
        } else {
          comboCount = 0;
          hideCombo();
        }

        renderGrid();
        renderPieces();

        // Check if all pieces are used
        if (currentPieces.every(p => p.used)) {
          setTimeout(spawnPieces, 200);
        } else if (!canPlaceAnyPiece()) {
          setTimeout(gameOver, 500);
        }
      }

      draggingPiece = null;
    }

    // ========== GAME LOGIC ==========
    function canPlacePiece(shape, startRow, startCol) {
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[0].length; c++) {
          if (!shape[r][c]) continue;
          const gr = startRow + r;
          const gc = startCol + c;
          if (gr < 0 || gr >= GRID_SIZE || gc < 0 || gc >= GRID_SIZE) return false;
          if (grid[gr][gc]) return false;
        }
      }
      return true;
    }

    function placePiece(shape, startRow, startCol) {
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[0].length; c++) {
          if (shape[r][c]) {
            grid[startRow + r][startCol + c] = 1;
          }
        }
      }
    }

    function checkAndClearLines() {
      let linesToClear = [];

      // Check rows
      for (let r = 0; r < GRID_SIZE; r++) {
        if (grid[r].every(cell => cell === 1)) {
          linesToClear.push({ type: 'row', index: r });
        }
      }

      // Check columns
      for (let c = 0; c < GRID_SIZE; c++) {
        let full = true;
        for (let r = 0; r < GRID_SIZE; r++) {
          if (!grid[r][c]) { full = false; break; }
        }
        if (full) linesToClear.push({ type: 'col', index: c });
      }

      if (linesToClear.length === 0) return 0;

      // Animate clearing
      linesToClear.forEach(line => {
        for (let i = 0; i < GRID_SIZE; i++) {
          let cellEl;
          if (line.type === 'row') {
            cellEl = document.querySelector(`.cell[data-row="${line.index}"][data-col="${i}"]`);
          } else {
            cellEl = document.querySelector(`.cell[data-row="${i}"][data-col="${line.index}"]`);
          }
          if (cellEl) cellEl.classList.add('clearing');
        }
      });

      // Clear grid data
      setTimeout(() => {
        linesToClear.forEach(line => {
          for (let i = 0; i < GRID_SIZE; i++) {
            if (line.type === 'row') {
              grid[line.index][i] = 0;
            } else {
              grid[i][line.index] = 0;
            }
          }
        });
        renderGrid();
      }, 350);

      return linesToClear.length;
    }

    function canPlaceAnyPiece() {
      for (const piece of currentPieces) {
        if (piece.used) continue;
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            if (canPlacePiece(piece.shape, r, c)) return true;
          }
        }
      }
      return false;
    }

    // ========== SCORING ==========
    function addScore(points) {
      score += points;
      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('blockblast_best', bestScore.toString());
      }
      updateScore();
    }

    function updateScore() {
      document.getElementById('score').textContent = score.toLocaleString();
      document.getElementById('bestScore').textContent = bestScore.toLocaleString();
    }

    function showCombo(multiplier) {
      const el = document.getElementById('combo');
      el.textContent = `COMBO x${multiplier}`;
      el.classList.add('visible');
    }

    function hideCombo() {
      document.getElementById('combo').classList.remove('visible');
    }

    function showScorePopup(points, x, y) {
      const popup = document.createElement('div');
      popup.className = 'score-popup';
      popup.textContent = `+${points}`;
      popup.style.left = x + 'px';
      popup.style.top = y + 'px';
      document.body.appendChild(popup);
      setTimeout(() => popup.remove(), 800);
    }

    // ========== GAME OVER ==========
    function gameOver() {
      document.getElementById('finalScore').textContent = score.toLocaleString();
      document.getElementById('finalBest').textContent = bestScore.toLocaleString();
      document.getElementById('gameOverOverlay').classList.add('visible');
    }

    // ========== EVENT LISTENERS ==========
    document.getElementById('newGameBtn').addEventListener('click', init);
    document.getElementById('playAgainBtn').addEventListener('click', init);
    document.getElementById('shareBtn').addEventListener('click', () => {
      const text = `Hice ${score.toLocaleString()} puntos en Block Blast de El Dorado! Puedes superarme?`;
      if (navigator.share) {
        navigator.share({ title: 'Block Blast - El Dorado', text });
      } else {
        navigator.clipboard.writeText(text);
        alert('Puntaje copiado!');
      }
    });

    // ========== START ==========
    document.getElementById('bestScore').textContent = bestScore.toLocaleString();
    init();
  </script>
</body>
</html>
